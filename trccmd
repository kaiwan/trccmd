#!/bin/bash
# https://github.com/kaiwan/trccmd/
#
# A simple wrapper over the useful trace-cmd front-end to ftrace.
# It uses the function_graph plugin.. records the session, generates the
# binary <cmd>_trc.dat file as well as a human-readable 'report' file,
# typically under /tmp/trc.txt.
# 
# As an additional feature, the binary data file generated by trace-cmd(1),
# can be imported into the Trace Compass GUI and better visualized.
# Details here: using_tracecompass_gui_with_trccmd.txt
# (online: https://github.com/kaiwan/trccmd/blob/main/using_tracecompass_gui_with_trccmd.txt)
#
# (c) Kaiwan N Billimoria, kaiwanTECH
# License: MIT

# Turn on Bash 'strict mode'!
# ref: http://redsymbol.net/articles/unofficial-bash-strict-mode/ 
set -euo pipefail

name=$(basename "$0")
hash trace-cmd >/dev/null 2>&1 || {
   echo "${name}: trace-cmd not installed (or not in PATH)?
First install the trace-cmd package and retry..."
   exit 1
}

[ "$(id -u)" -eq 0 ] && {
 echo "${name}: Please don't run as root."
 exit 1
}

# Check for the config file
# If it isn't present, this is likely the first run; install it
# If present, source it in!
CONFIG=~/.local/trccmd.config
if [ ! -f ${CONFIG} ] ; then
   echo "${name}: as this is (likely) your very first run, we're installing the trccmd config file ...
(to ${CONFIG})"
   if [ ! -f ./trccmd.config ] ; then
     echo "${name}: ensure that it's first run from within the trccmd GitHub repo directory only..."
	 exit 1
   fi
   mkdir -p ~/.local
   cp ./trccmd.config ~/.local/
fi
source ${CONFIG} || {
	echo "${name}: fatal: could not source file '${CONFIG}', aborting...
(Please ensure you 'git clone' the full repo to get the config file as well!)"
	exit 1
}
echo "${name}: config parsed from ${CONFIG}"

usage()
{
   echo "
======= trccmd Help screen =======

Usage:
${name} [-h] [-e 'subsystem1 subsystem2 ...'] [-F 'program-to-trace [arg1] [arg2] ...']

 Eg. ./${name} -e 'syscalls kmem' -F 'ps -LA'

 NOTE:
 a) -F: this will perform an _exclusive_ ftrace of the provided app ('ps -LA' in the above eg).
 b) -e: the -e 'events' switch allows you to trace particular subsystems (default: all)! Pick
    from among the ones shown below; you can specify as many as you like, just separate them
	with a space:

$(sudo trace-cmd list |awk -F':' 'NF==2 {print $1}'|sort -t':' -k1 |uniq|tr '\n' ' ')

    Not using the -e option has trccmd attempt to trace _all_ events

 c) ensure you surround the -e and/or -F arguments with single quotes '...'
 d) If no program is provided as an argument, we shall trace-cmd(1) whatever's running on the system
 e) The config file's here:
     ${CONFIG}

 If you want to *see all function parameters and their runtime values*
 (useful!), ensure the variable SHOW_PARAMETERS is set to 1 in the config file
 (check it out, useful stuff within). You will, however, lose the function graph indentation
 when parameters are enabled.

 f) pass only '-h' to ${name} to see this Help screen.

 TIP:
 See (and try!) the sample_usage script."
}

show_config()
{
echo "QUIET_MODE         = ${QUIET_MODE}"
echo "DONT_REPORT_IRQCTX = ${DONT_REPORT_IRQCTX}"
echo "SHOW_PARAMETERS    = ${SHOW_PARAMETERS}"
echo "SKIP_FTRACE_CHECK  = ${SKIP_FTRACE_CHECK}"
echo "USE_MARKERS        = ${USE_MARKERS}"
echo "SKIP_LENGTHY_FTRACE_CHECK  = ${SKIP_LENGTHY_FTRACE_CHECK}"
}


## "main" here

TRCCMD_EVENTS=/tmp/trccmd.evs.$$
if [[ $# -eq 1 && "$1" = "-h" ]] ; then
	usage
	exit 0
fi
sudo trace-cmd list |awk -F':' 'NF==2 {print $1}'|sort -t':' -k1 |uniq|tr '\n' ' ' > ${TRCCMD_EVENTS}

EVENTS=""
PRG=""
while getopts ":he:F:" arg; do
  case $arg in
    F) # Specify prg to run
	  PRG="${OPTARG}"
      ;;
    e) # Specify event subsystems (or globs)
	  for ev in ${OPTARG}
	  do
		# don't use grep -q ! it can work unexpectedly with the 'if' as ret values aren't what's expected..
		grep "${ev}" ${TRCCMD_EVENTS} >/dev/null || {
		   echo "${name}: fatal: event \"${ev}\" unavailable"
		   rm -f ${TRCCMD_EVENTS}
		   exit 1
		}
		EVENTS="${EVENTS} -e ${ev}"
	  done
      #echo "ev = ${EVENTS}"
      ;;
    h | *) # Display help.
      usage
      rm -f ${TRCCMD_EVENTS}
      exit 0
      ;;
  esac
done
[[ -z "${EVENTS}" ]] && EVENTS="-e all"

echo "[+] Checking for ftrace support ..."
# tracefs from 4.1
sudo mount |grep -w tracefs >/dev/null || {
  echo "${name}: tracefs filesystem not mounted? Aborting..."
  rm -f ${TRCCMD_EVENTS}
  exit 2
}
TRCMNT=$(sudo mount |grep -w tracefs |head -n1|awk '{print $3}')
export TRCMNT
# if /sys/kernel/debug then append 'tracing' else don't (for /sys/kernel/tracing)
echo "${TRCMNT}" |grep debug >/dev/null && TRCMNT=${TRCMNT}/tracing
NF=$(sudo ls "${TRCMNT}" 2>/dev/null |wc -w)
if [ "${NF}" -le 0 ] ; then
 echo "${name}: ${TRCMNT} no pseudo-files available? Aborting..."
 rm -f ${TRCCMD_EVENTS}
 exit 3
fi
echo " [OK] (ftrace loc: ${TRCMNT})"

#show_config

#-------------- test for the 'function_graph' plugin support
if [ "${SKIP_LENGTHY_FTRACE_CHECK}" -eq 0 ]; then
 echo -n "[+] Checking for trace-cmd with function_graph plugin support, pl wait ..."
 hash trace-cmd >/dev/null 2>&1 || {
   echo "${name}: trace-cmd not installed (or not in PATH)?"
   rm -f ${TRCCMD_EVENTS}
   exit 1
 }

 mv trace.dat trace.dat.bkp 2>/dev/null
 TESTFUNC=__do_sys_getpid
 if ! sudo grep -w ${TESTFUNC} "${TRCMNT}"/available_filter_functions >/dev/null ; then
   echo "${name}: test func ${TESTFUNC} not available, aborting test..."
   rm -f ${TRCCMD_EVENTS}
   exit 4
 else
  sudo trace-cmd record -p function_graph -l ${TESTFUNC} -F true >/dev/null 2>&1 || {
    echo "${name}: trace-cmd didn't work with the function-graph plugin, aborting..."
    rm -f ${TRCCMD_EVENTS}
    exit 5
  }
 fi
 sudo rm -f trace.dat 2>/dev/null
 mv trace.dat.bkp trace.dat 2>/dev/null
 echo " [OK]"
else
 echo "[.] config: skip lengthy ftrace function_graph check"
fi

echo "Reset..."
sudo trace-cmd reset

#------------------ RECORD
TRC_FILE_BINARY=trc_all.dat
if [ $# -ge 1 ] ; then
  TRC_FILE_BINARY=$(basename "${name}")_trc.dat
else
  echo "Will now attempt a system-wide trace..."
fi
#echo "TRC_FILE_BINARY = ${TRC_FILE_BINARY}"

OPTS_RECORD="-o ${TRC_FILE_BINARY}"
[ "${QUIET_MODE}" -eq 1 ] && OPTS_RECORD="${OPTS_RECORD} -q"
if [ "${SHOW_PARAMETERS}" -eq 1 ] ; then
  echo "
  Recording: showing parameters and their runtime values; will lose function-graph...
  "
else
  OPTS_RECORD="${OPTS_RECORD} -p function_graph"
fi

echo "[+] Recording now ...(binary ftrace file is ${TRC_FILE_BINARY})
[rec options: \"${OPTS_RECORD}\"]

<< This can take a while, be patient ...
 (Pl at least wait for a message onscreen before doing anything)
 Also, if you must abort, hit Ctrl^C just once (again, be patient, it can take time before a response) >>
"

OPTS_RECORD="${OPTS_RECORD} ${EVENTS}"

if [ $# -ge 1 ] ; then
  cmd="sudo trace-cmd record ${OPTS_RECORD} -c -F ${PRG}"  #"$@""
   # -F: trace only this executable
   # -c: ...along with it's children, if any
else
  cmd="sudo trace-cmd record ${OPTS_RECORD}"
fi

echo "> ${cmd}"
[ "${USE_MARKERS}" -eq 1 ] && {
 sudo sh -c "echo markers > ${TRCMNT}/trace_options"
 sudo sh -c "echo START > ${TRCMNT}/trace_marker"
}
eval "${cmd}"
if [ $? -ne 0 ]; then
  echo "${name}: command \"${cmd}\" failed, aborting ..."
  rm -f ${TRCCMD_EVENTS}
  exit 6
fi
[ "${USE_MARKERS}" -eq 1 ] && sudo sh -c "echo END > ${TRCMNT}/trace_marker"

ls "${TRC_FILE_BINARY}" >/dev/null || {
  echo "${name}: 'trace-cmd record' failed, no binary trace file, aborting ..."
  rm -f ${TRCCMD_EVENTS}
  exit 7
}
sudo chown "${USER}":"${USER}" "${TRC_FILE_BINARY}"

#------------------ REPORT
echo
echo "[+] Generating the trace-cmd report now ..."
echo -n "    Note: report done in latency format"
OPTS_REPORT="-l -i ${TRC_FILE_BINARY}"
 # -l : adds a "latency output" format
 # -i : input file spec
[ "${QUIET_MODE}" -eq 1 ] && OPTS_REPORT="${OPTS_REPORT} -q"
[ "${DONT_REPORT_IRQCTX}" -eq 1 ] && {
  echo ", *leaving out* interrupt contexts"
  OPTS_REPORT="${OPTS_REPORT} -I -S"
}

cmd="sudo trace-cmd report ${OPTS_REPORT} > ${TRC_FILE}"
echo "
> ${cmd}"
eval "${cmd}"
if [ $? -ne 0 ]; then
    echo "${name}: command \"${cmd}\" failed, aborting ..."
    rm -f ${TRCCMD_EVENTS}
    exit 6
fi
echo "[+] Done"  #, report: ${TRC_FILE}"

echo "
trace-cmd report file: ${TRC_FILE}
$(ls -lh "${TRC_FILE}")

Additionally:
The binary data file generated by trace-cmd, here
    $(ls -lh "${TRC_FILE_BINARY}")
can be imported into the KernelShark and/or Trace Compass GUIs and better visualized.
Details here:
KernelShark: https://kernelshark.org/Documentation.html
TraceCompass: using_tracecompass_gui_with_trccmd.txt
 (online: https://github.com/kaiwan/trccmd/blob/main/using_tracecompass_gui_with_trccmd.txt)"
rm -f ${TRCCMD_EVENTS}
exit 0
