#!/bin/bash
# https://github.com/kaiwan/trccmd/
#
# A simple wrapper over the useful trace-cmd front-end to ftrace.
# It uses the function_graph plugin.. records the session, generates the
# binary <cmd>_trc.dat file as well as a human-readable 'report' file,
# typically under /tmp/trc.txt.
# 
# As an additional feature, the binary data file generated by trace-cmd(1),
# can be imported into the Trace Compass GUI and better visualized.
# Details here: using_tracecompass_gui_with_trccmd.txt
# (online: https://github.com/kaiwan/trccmd/blob/main/using_tracecompass_gui_with_trccmd.txt)
#
# (c) Kaiwan N Billimoria, kaiwanTECH
# License: MIT

# Turn on Bash 'strict mode'!
# ref: http://redsymbol.net/articles/unofficial-bash-strict-mode/ 
set -euo pipefail

die()
{
echo >&2 "FATAL: $*"
exit 1
}


name=$(basename "$0")
TRACE_CMD=trace-cmd  # default: locate trace-cmd via PATH
#TRACE_CMD=<...>/trace-cmd  # you're free to change it to a later ver or whatever...

hash ${TRACE_CMD} >/dev/null 2>&1 || die "${name}: trace-cmd not installed (or not in PATH)?
First install the trace-cmd package and retry..."
[ "$(id -u)" -eq 0 ] && die "${name}: Please don't run as root."

# Check for the config file
# If it isn't present, this is likely the first run; install it
# If present, source it in!
CONFIG=~/.local/trccmd.config
if [ ! -f ${CONFIG} ] ; then
   echo "${name}: as this is (likely) your very first run, we're installing the trccmd config file ...
(to ${CONFIG})"
   if [ ! -f ./trccmd.config ] ; then
     die "${name}: ensure that it's first run from within the trccmd GitHub repo directory only..."
   fi
   mkdir -p ~/.local
   cp ./trccmd.config ~/.local/
fi
source ${CONFIG} || die "${name}: fatal: could not source file '${CONFIG}', aborting...
(Please ensure you 'git clone' the full repo to get the config file as well!)"
echo "${name}: config parsed from ${CONFIG}"

whats_show_params() {
[[ ${SHOW_PARAMETERS} -eq 0 ]]  && echo -n "isn't" || echo -n "is"
}

usage()
{
   echo "
======= trccmd Help screen =======

Usage:
${name} [-h] [-e 'subsystem1 subsystem2 ...'] [-F 'program-to-trace [arg1] [arg2] ...']

 Eg. ./${name} -e 'syscalls kmem' -F 'ps -LA'

 NOTE:
 a) -F: this will perform an _exclusive_ ftrace of the provided app ('ps -LA' in the above eg).
 b) -e: the -e 'events' switch allows you to trace particular subsystems (default: all)! Pick
    from among the ones shown below; you can specify as many as you like, just separate them
	with a space:

$(sudo ${TRACE_CMD} list |awk -F':' 'NF==2 {print $1}'|sort -t':' -k1 |uniq|tr '\n' ' ')

    Not using the -e option has trccmd attempt to trace _all_ events

 c) ensure you surround the -e and/or -F arguments with single quotes '...'
 d) If no program is provided as an argument, we shall ${TRACE_CMD}(1) whatever's running on the system
 e) Configs: the config file's here:
     ${CONFIG}
 
Current config values are as follows (you can always edit the config file to change them):
$(show_config)

 If you want to *see all function parameters and their runtime values*
 (useful!), ensure the variable SHOW_PARAMETERS is set to 1 (it currently $(whats_show_params)). It's a trade-off:
 the report too (in ${TRC_FILE}) is *much* more concise but you will, however, lose the
 function graph indentation when parameters are enabled.

 f) pass only '-h' to ${name} to see this Help screen.

 TIP:
 See (and try!) the sample_usage script."
}

show_config()
{
echo "DONT_REPORT_IRQCTX         = ${DONT_REPORT_IRQCTX}"
echo "QUIET_MODE                 = ${QUIET_MODE}"
echo "SHOW_PARAMETERS            = ${SHOW_PARAMETERS}"
echo "SKIP_LENGTHY_FTRACE_CHECK  = ${SKIP_LENGTHY_FTRACE_CHECK}"
echo "TRC_FILE                   = ${TRC_FILE}"
echo "USE_MARKERS                = ${USE_MARKERS}"
}


## "main" here

TRCCMD_EVENTS=/tmp/trccmd.evs.$$
if [[ $# -eq 1 && "$1" = "-h" ]] ; then
	usage
	exit 0
fi
sudo ${TRACE_CMD} list |awk -F':' 'NF==2 {print $1}'|sort -t':' -k1 |uniq|tr '\n' ' ' > ${TRCCMD_EVENTS}

EVENTS=""
PRG=""
while getopts ":he:F:" arg; do
	#echo "arg = $arg"
  case $arg in
    F) # Specify prg to run
	  PRG="${OPTARG}"
      ;;
    e) # Specify event subsystems (or globs)
	  for ev in ${OPTARG}
	  do
		# don't use grep -q ! it can work unexpectedly with the 'if' as ret values aren't what's expected..
		grep "${ev}" ${TRCCMD_EVENTS} >/dev/null || {
		   rm -f ${TRCCMD_EVENTS}
		   die "${name}: fatal: event \"${ev}\" unavailable"
		}
		EVENTS="${EVENTS} -e ${ev}"
	  done
      #echo "ev = ${EVENTS}"
      ;;
    h) # Display help.
      usage
      rm -f ${TRCCMD_EVENTS}
      exit 0
      ;;
    *) # Anything else, display help.
      usage
      rm -f ${TRCCMD_EVENTS}
      exit 1
      ;;
  esac
done
#echo "
#Params: # = $# : $*
#"
if [[ $# -ge 1 ]] && [[ "$1" != "-F" ]] && [[ "$1" != "-e" ]] && [[ "$1" != "-h" ]] ; then
	usage
	exit 1
fi

[[ -z "${EVENTS}" ]] && EVENTS="-e all"

echo "[+] Checking for ftrace support ..."
# tracefs from 4.1
sudo mount |grep -w tracefs >/dev/null || {
  echo "${name}: tracefs filesystem not mounted? Aborting..."
  rm -f ${TRCCMD_EVENTS}
  exit 2
}
TRCMNT=$(sudo mount |grep -w tracefs |head -n1|awk '{print $3}')
export TRCMNT
# if /sys/kernel/debug then append 'tracing' else don't (for /sys/kernel/tracing)
echo "${TRCMNT}" |grep debug >/dev/null && TRCMNT=${TRCMNT}/tracing
NF=$(sudo ls "${TRCMNT}" 2>/dev/null |wc -w)
if [ "${NF}" -le 0 ] ; then
 echo "${name}: ${TRCMNT} no pseudo-files available? Aborting..."
 rm -f ${TRCCMD_EVENTS}
 exit 3
fi
echo " [OK] (ftrace loc: ${TRCMNT})"

#-------------- test for the 'function_graph' plugin support
if [ "${SKIP_LENGTHY_FTRACE_CHECK}" -eq 0 ]; then
 echo -n "[+] Checking for trace-cmd with function_graph plugin support, pl wait ..."
 hash ${TRACE_CMD} >/dev/null 2>&1 || {
   echo "${name}: ${TRACE_CMD} not installed (or not in PATH)?"
   rm -f ${TRCCMD_EVENTS}
   die "${name}: trace-cmd not installed (or not in PATH)?"
 }

 mv trace.dat trace.dat.bkp 2>/dev/null
 TESTFUNC=__do_sys_getpid
 if ! sudo grep -w ${TESTFUNC} "${TRCMNT}"/available_filter_functions >/dev/null ; then
   echo "${name}: test func ${TESTFUNC} not available, aborting test..."
   rm -f ${TRCCMD_EVENTS}
   exit 4
 else
  sudo ${TRACE_CMD} record -p function_graph -l ${TESTFUNC} -F true >/dev/null 2>&1 || {
    echo "${name}: ${TRACE_CMD} didn't work with the function-graph plugin, aborting..."
    rm -f ${TRCCMD_EVENTS}
    exit 5
  }
 fi
 sudo rm -f trace.dat 2>/dev/null
 mv trace.dat.bkp trace.dat 2>/dev/null
 echo " [OK]"
else
 echo "[.] config: skip lengthy ftrace function_graph check"
fi

echo "[+] Reset..."
sudo ${TRACE_CMD} reset

#------------------ RECORD
TRC_FILE_BINARY=trc_all.dat
if [ $# -ge 1 ] ; then
  TRC_FILE_BINARY=$(basename "${name}")_trc.dat
else
  echo "Will now attempt a system-wide trace..."
fi
#echo "TRC_FILE_BINARY = ${TRC_FILE_BINARY}"

OPTS_RECORD="-o ${TRC_FILE_BINARY}"
[ "${QUIET_MODE}" -eq 1 ] && OPTS_RECORD="${OPTS_RECORD} -q"
if [ "${SHOW_PARAMETERS}" -eq 1 ] ; then
  echo "
  Recording: showing parameters and their runtime values; will lose function-graph layout...
  "
else
  echo "
  Recording: NOT showing parameters; will gain function-graph layout...
  "
  OPTS_RECORD="${OPTS_RECORD} -p function_graph"
fi

echo "[+] Recording now ...(binary ftrace file is ${TRC_FILE_BINARY})
[rec options: \"${OPTS_RECORD}\"]

<< This can take a while, be patient ...
 (Pl at least wait for a message onscreen before doing anything)
 Also, if you must abort, hit Ctrl^C just once (again, be patient, it can take time before a response) >>
"

OPTS_RECORD="${OPTS_RECORD} ${EVENTS}"

if [ $# -ge 1 ] ; then
  cmd="sudo ${TRACE_CMD} record ${OPTS_RECORD} -c -F ${PRG}"  #"$@""
   # -F: trace only this executable
   # -c: ...along with it's children, if any
else
  cmd="sudo ${TRACE_CMD} record ${OPTS_RECORD}"
fi

echo "> ${cmd}"
[ "${USE_MARKERS}" -eq 1 ] && {
 sudo sh -c "echo markers > ${TRCMNT}/trace_options"
 sudo sh -c "echo START > ${TRCMNT}/trace_marker"
}
eval "${cmd}"
if [ $? -ne 0 ]; then
  echo "${name}: command \"${cmd}\" failed, aborting ..."
  rm -f ${TRCCMD_EVENTS}
  exit 6
fi
[ "${USE_MARKERS}" -eq 1 ] && sudo sh -c "echo END > ${TRCMNT}/trace_marker"

ls "${TRC_FILE_BINARY}" >/dev/null || {
  echo "${name}: '${TRACE_CMD} record' failed, no binary trace file, aborting ..."
  rm -f ${TRCCMD_EVENTS}
  exit 7
}
sudo chown "${USER}":"${USER}" "${TRC_FILE_BINARY}"

#------------------ REPORT
echo
echo "[+] Generating the trace-cmd report now ..."
echo -n "    Note: report done in latency format"
OPTS_REPORT="-l -i ${TRC_FILE_BINARY}"
 # -l : adds a "latency output" format
 # -i : input file spec
[ "${QUIET_MODE}" -eq 1 ] && OPTS_REPORT="${OPTS_REPORT} -q"
[ "${DONT_REPORT_IRQCTX}" -eq 1 ] && {
  echo ", *leaving out* interrupt contexts"
  OPTS_REPORT="${OPTS_REPORT} -I -S"
}

cmd="sudo ${TRACE_CMD} report ${OPTS_REPORT} > ${TRC_FILE}"
echo "
> ${cmd}"
eval "${cmd}"
if [ $? -ne 0 ]; then
    echo "${name}: command \"${cmd}\" failed, aborting ..."
    rm -f ${TRCCMD_EVENTS}
    exit 6
fi
echo "[+] Done"  #, report: ${TRC_FILE}"

echo "
trace-cmd report file: ${TRC_FILE}
$(ls -lh "${TRC_FILE}")

Additionally:
The binary data file generated by trace-cmd, here
    $(ls -lh "${TRC_FILE_BINARY}")
can be imported into the KernelShark and/or Trace Compass GUIs and better visualized.
Details here:
KernelShark: https://kernelshark.org/Documentation.html
TraceCompass: using_tracecompass_gui_with_trccmd.txt
 (online: https://github.com/kaiwan/trccmd/blob/main/using_tracecompass_gui_with_trccmd.txt)"
rm -f ${TRCCMD_EVENTS}
exit 0
